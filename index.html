<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiddler Scoring App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tippy.js Tooltip Dependencies -->
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="https://unpkg.com/tippy.js@6"></script>
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6/animations/scale.css"/>
</head>
<body class="bg-gray-100 p-4">
    <div class="max-w-4xl mx-auto bg-white shadow-md rounded-lg p-6">
        <h1 class="text-2xl font-bold mb-4">Quiddler Scoring App</h1>

        <div class="mb-4">
            <label class="block font-semibold">Player Names (comma separated):</label>
            <input id="playersInput" class="w-full p-2 border rounded mt-2" placeholder="e.g., Alice,Bob,Charlie">
            <div class="mt-2 space-y-2">
                <div class="flex items-center gap-2">
                    <input type="checkbox" id="longestWordBonus">
                    <label for="longestWordBonus">Longest Word Bonus ü¶í</label>
                    <input id="longestWordPoints" type="number" value="10" min="0" value="20"
                        class="w-16 border rounded p-1">
                    <span>points</span>
                </div>
                <div class="flex items-center gap-2">
                    <input type="checkbox" id="mostWordsBonus">
                    <label for="mostWordsBonus">Most Words Bonus ü•í</label>
                    <input id="mostWordsPoints" type="number" value="10" min="0" value="20"
                        class="w-16 border rounded p-1">
                    <span>points</span>
                </div>
            </div>
            <button onclick="startGame()" class="mt-3 bg-blue-500 text-white py-2 px-4 rounded">Start Game</button>
        </div>

        <div id="gameArea" class="hidden">
            <h2 class="font-semibold text-xl mb-2" id="roundHeader"></h2>

            <div id="scoreInputs"></div>

            <button onclick="nextRound()" class="mt-3 bg-blue-500 text-white py-2 px-4 rounded">Submit Round</button>

            <h3 class="font-semibold text-xl mt-6">Running Totals</h3>
            <ul id="scoreTotals" class="list-disc pl-6"></ul>

            <h3 class="font-semibold text-xl mt-6">Previous Rounds</h3>
            <div id="previousRounds" class="mt-2"></div>
        </div>
    </div>

    <!-- Tools Drawer Toggle Button -->
    <div class="fixed bottom-6 right-6 flex flex-col gap-3 z-50">
      <button id="dictToolBtn"
              class="w-14 h-14 rounded-full bg-gray-500 hover:bg-gray-600 flex items-center justify-center shadow-lg"
              aria-label="Open Dictionary"
              data-tippy-content="Dictionary"
              type="button">
        <img src="https://cdn.jsdelivr.net/npm/heroicons@2.1.5/24/outline/book-open.svg"
             class="w-7 h-7 invert" alt="" />
      </button>

      <button id="optToolBtn"
              class="w-14 h-14 rounded-full bg-gray-500 hover:bg-gray-600 flex items-center justify-center shadow-lg"
              aria-label="Open Optimizer"
              data-tippy-content="Solver"
              type="button">
        <img src="https://cdn.jsdelivr.net/npm/heroicons@2.1.5/24/outline/cog-6-tooth.svg"
             class="w-7 h-7 invert" alt="" />
      </button>
    </div>

    <!-- Backdrop -->
    <div id="toolsBackdrop"
         class="fixed inset-0 bg-black/30 z-40 hidden opacity-0 transition-opacity"></div>

    <!-- Right Drawer -->
    <aside id="toolsDrawer"
           class="fixed right-0 top-0 h-full w-[24rem] max-w-[90vw] bg-white z-50 shadow-xl border-l border-gray-200
                  transform translate-x-full transition-transform">
      <!-- Header -->
      <div class="flex items-center justify-between px-4 py-3 border-b border-gray-200 bg-gray-50">
        <div class="font-semibold text-gray-800">Quiddler Tools</div>
        <button id="toolsCloseBtn" class="text-gray-500 hover:text-gray-700 text-xl leading-none">‚úï</button>
      </div>

      <!-- Tabs -->
      <div class="px-4 pt-3">
        <div class="inline-flex text-sm rounded-lg overflow-hidden border border-gray-200">
          <button id="toolsTabDict" class="px-3 py-2 bg-white text-gray-900">Dictionary</button>
          <button id="toolsTabPlay" class="px-3 py-2 bg-gray-100 text-gray-600">Solver</button>
        </div>
      </div>

      <!-- Panels -->
      <div class="p-4 flex flex-col gap-4 overflow-y-auto h-[calc(100%-4.5rem-3rem)]">
        <!-- Dictionary panel -->
        <section id="toolsPanelDict">

          <div id="dictEmpty" class="mb-3 text-sm text-gray-500">Enter a word and press <kbd class="px-1 py-0.5 bg-gray-200 rounded">Enter</kbd> or click <em>Look up</em>.</div>
          <div class="flex items-center gap-2 mb-3">
            <input id="dictInput" type="text" placeholder="Type a word‚Ä¶" class="flex-1 border rounded-lg px-3 py-2 outline-none focus:ring focus:ring-blue-200"/>
            <button id="dictGo" class="bg-blue-600 text-white px-3 py-2 rounded-lg hover:bg-blue-700">Look up</button>
          </div>

          <!-- Dictionary content -->
          <div id="dictContent" class="space-y-3">
            <!-- Local definition -->
            <div id="dictLocalWrap" class="hidden">
              <div class="text-xs uppercase tracking-wide text-gray-500 mb-1">Collins ‚Äô19</div>
              <div id="dictLocal" class="text-sm text-gray-800"></div>
            </div>
            <!-- Online definition -->
            <div id="dictOnlineWrap" class="hidden">
              <div class="text-xs uppercase tracking-wide text-gray-500 mb-1">Online Dictionary</div>
              <div id="dictOnline" class="text-sm text-gray-800"></div>
            </div>
            <!-- Loading -->
            <div id="dictOnlineLoading" class="hidden text-xs text-gray-500">Looking up‚Ä¶</div>
          </div>

        </section>

        <!-- Play Helper panel -->
        <section id="toolsPanelPlay" class="hidden">
          <!-- Tiles -->
        <div id="tilesEmpty" class="mb-3 text-sm text-gray-500">
          Enter your hand, using parentheses around digraphs:
        </div>

        <!-- Tiles input -->
        <div>
          <input id="tilesInput" type="text" placeholder="e.g. (qu)i ck(er)"
                 class="w-full border rounded-lg px-3 py-2 outline-none focus:ring focus:ring-blue-200"/>
        </div>

        <!-- New: "Do not discard a card" -->
        <div class="mt-3">
          <label class="inline-flex items-center gap-2">
            <input id="optNoDiscard" type="checkbox" class="rounded">
            <span class="text-sm">Do not discard any card</span>
          </label>
        </div>

        <!-- Common/Zipf controls -->
        <div class="mt-4 mb-2 space-y-2">
          <!-- Only consider words with Zipf of ... (with link) -->
          <label class="flex flex-wrap items-center gap-2">
            <input id="optCommonOnly" type="checkbox" class="rounded">
            <span class="text-sm">
              Consider only words with a
              <a href="https://en.wikipedia.org/wiki/Zipf%27s_law" target="_blank" rel="noopener noreferrer"
                 class="text-blue-600 hover:underline">Zipf</a>
              score of:
              <span id="zipfVal" class="font-semibold">2.0</span>
            </span>
          </label>

          <!-- Zipf slider -->
          <input id="optZipf" type="range" min="0" max="5" step="0.1" value="2.0"
                 class="w-full accent-blue-600">

          <!-- But include 2- and 3-letter words -->
          <label class="inline-flex items-center gap-2">
            <input id="optCommonOverride" type="checkbox" class="rounded">
            <span class="text-sm">Except include all 2 and 3 letter words</span>
          </label>
        </div>

          <!-- Current Longest / Current Most -->
          <div id="currentBonuses" class="grid grid-cols-2 gap-3 hidden">
            <div>
              <label for="optCurrentLongest" class="block text-sm font-medium text-gray-700 mb-1">Longest word to beat</label>
              <input id="optCurrentLongest" type="number" min="0" step="1" value="0"
                     class="w-full border rounded-lg px-3 py-2 text-right outline-none focus:ring focus:ring-blue-200"/>
            </div>
            <div>
              <label for="optCurrentMost" class="block text-sm font-medium text-gray-700 mb-1">Most words to beat</label>
              <input id="optCurrentMost" type="number" min="0" step="1" value="0"
                     class="w-full border rounded-lg px-3 py-2 text-right outline-none focus:ring focus:ring-blue-200"/>
            </div>
          </div>

          <!-- Action + Status -->
          <div class="mt-3 pt-2 flex items-center gap-2">
            <button id="playGo" class="bg-blue-500 text-white px-3 py-2 rounded-lg">
              Solve
            </button>
            <span id="playStatus" class="text-sm text-gray-500"></span>
          </div>

          <!-- Results -->
          <div id="playResult" class="mt-2 hidden"></div>

        </section>
      </div>
    </aside>

    <script src="collins_dictionary.js"></script>
    <script src="card_scores.js"></script>
    <script src="common_lemmas.js"></script>
    <script type="module">
        import lemmatizer from "https://cdn.jsdelivr.net/npm/wink-lemmatizer/+esm";
        window.winkLemmatizer = lemmatizer; // make it global for the rest of your code
    </script>
    <script>
        let gameStarted = false;
        let players = [];
        let scores = {};
        let currentRound = 3;
        const maxRound = 10;
        let roundsData = [];
        let longestWordBonus = false;
        let mostWordsBonus = false;
        let longestWordPoints = 0;
        let mostWordsPoints = 0;
        let currentDealerIdx = 0;

        function startGame() {
            // Parse and clean players list
            players = document.getElementById('playersInput').value
                .split(',')
                .map(p => p.trim())
                .filter(p => p.length > 0)
                .map(p => p.charAt(0).toUpperCase() + p.slice(1).toLowerCase());

            if (!players.length) {
                alert('Please enter at least one player');
                return;
            }

            // Reset all global variables to initial state
            gameStarted = true;
            scores = {};
            currentRound = 3;
            roundsData = [];
            currentDealerIdx = 0;
            longestWordBonus = document.getElementById('longestWordBonus').checked;
            mostWordsBonus = document.getElementById('mostWordsBonus').checked;
            longestWordPoints = +document.getElementById('longestWordPoints').value;
            mostWordsPoints = +document.getElementById('mostWordsPoints').value;

            // Initialize player scores
            players.forEach(player => scores[player] = 0);

            // Disable inputs after initial setup
            document.getElementById('playersInput').disabled = true;
            document.getElementById('longestWordBonus').disabled = true;
            document.getElementById('mostWordsBonus').disabled = true;
            document.getElementById('longestWordPoints').disabled = true;
            document.getElementById('mostWordsPoints').disabled = true;

            // Clear previous game state from UI
            document.getElementById('scoreTotals').innerHTML = '';
            document.getElementById('previousRounds').innerHTML = '';

            // Make game area visible and start first round
            document.getElementById('gameArea').classList.remove('hidden');
            document.getElementById("currentBonuses").classList.remove('hidden');
            setupRound();
        }

        function setupRound() {
            const dealer = players[currentDealerIdx % players.length];
            document.getElementById('roundHeader').innerText = `Round ${currentRound} Cards (${dealer} deals)`;

            document.getElementById('scoreInputs').innerHTML = `
                <div class="mb-2 font-medium">Enter your words separated by spaces, using parentheses around digraphs and a '-' prefix before all unused cards.</div>
                ${players.map(player => `
                    <div class="mb-2 flex items-center">
                        <label class="font-semibold mr-2">${player}'s words:</label>
                        <input class="player-words flex-1 p-2 border rounded" data-player="${player}" placeholder="e.g., (qu)ick(er) bad -e(th)">
                    </div>
                `).join('')}`;

            currentDealerIdx++;
        }

        function validateWord(word) {
            const cleanedWord = word.replace(/[()]/g, '').toUpperCase();
            return validWordsMap.hasOwnProperty(cleanedWord);
        }

        // Top-level: try API first; if it fails/returns null, fall back to local.
        // Returns a string: either HTML with <br> breaks, a local definition, or the not-found message.
        async function getWordDefinition(word) {
          const cleanedWord = (word ?? "").replace(/[()]/g, "").trim();
          if (!cleanedWord) return "Definition not found...";

          // Try API (catch to ensure fallback still runs)
          let definition = null;
          try {
            definition = await getWordDefinitionAPI(cleanedWord);
          } catch {
            // swallow; we'll fall back to local
          }

          if (definition == null) {
            definition = getWordDefinitionLocal(cleanedWord);
          }

          return definition ?? "Definition not found...";
        }

        // Local lookup (case-insensitive via UPPER)
        function getWordDefinitionLocal(word) {
            return validWordsMap[word.toUpperCase()] ?? null;
        }

        // API helper: returns a string with <br> between senses, or null on failure/no match.
        async function getWordDefinitionAPI(word) {
          const url = `https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(
            word.toLowerCase()
          )}`;

          // Optional: simple timeout so we don't hang forever
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 8000);

          try {
            const response = await fetch(url, { signal: controller.signal });
            if (!response.ok) {
              console.warn(`Free Dictionary API error for "${word}": ${response.status}`);
              return null;
            }

            const data = await response.json();
            if (!Array.isArray(data) || data.length === 0) return null;

            // Build a nice string with numbered senses
            let i = 0;
            const ret = [];

            for (const datum of data) {
              if ((datum.word || "").toLowerCase() !== word.toLowerCase()) continue;
              for (const meaning of datum.meanings ?? []) {
                let pos = meaning.partOfSpeech || "";
                if (pos === "interjection") pos = "interj";
                for (const def of meaning.definitions ?? []) {
                  if (!def?.definition) continue;
                  i++;
                  ret.push(`[${i}] (${pos}) ${def.definition}`);
                }
              }
            }

            return ret.length ? ret.join("<br>") : null;
          } catch (error) {
            console.error("Free Dictionary API request/parsing failed:", error);
            return null;
          } finally {
            clearTimeout(timeoutId);
          }
        }


        function parseCards(word) {
            return word.match(/\([a-z]+\)|[a-z]/gi) || [];
        }

        function calculateScore(cards) {
            return cards.reduce((total, card) => total + (cardScores[card.replace(/[()]/g, "").toLowerCase()] || 1), 0);
        }

        function nextRound() {
            const round = { roundNum: currentRound, players: {} };

            document.querySelectorAll('.player-words').forEach(input => {
                const player = input.dataset.player;
                const words = input.value.trim().split(/\s+/).filter(w => w);
                round.players[player] = words.map(word => ({
                    text: word,
                    score: calculateScore(parseCards(word.replace('-', ''))),
                    state: word.startsWith('-') ? 'invalid' : 'neutral',
                    challenger: null
                }));
            });

            roundsData.push(round);

            recalculateScores();
            updatePreviousRounds();

            currentRound < maxRound ? (++currentRound, setupRound()) : alert('Game Over! Check final scores.');
        }

        // ---------- Helpers ----------

        // A word counts toward base if it's not invalid OR it's invalid with no challenger (definition-only / unchallenged).
        function eligibleForBase(word) {
          return (word.state !== 'invalid') || (word.state === 'invalid' && word.challenger == null);
        }

        // A word counts toward bonuses if it is NOT a '-' chit and passes base eligibility.
        function eligibleForBonus(word) {
          return !word.text.startsWith('-') && eligibleForBase(word);
        }

        // Base score contribution (handles '-' penalty)
        function wordBaseValue(word) {
          const sign = word.text.startsWith('-') ? -1 : 1;
          return sign * word.score;
        }

        // Compute base score for a player's words
        function baseScoreForPlayer(pdata) {
          return pdata.reduce((sum, w) => sum + (eligibleForBase(w) ? wordBaseValue(w) : 0), 0);
        }

        // Filter words eligible for bonuses for a player
        function bonusEligibleWords(pdata) {
          return pdata.filter(eligibleForBonus);
        }

        // Longest word length (by letters; parentheses removed)
        function longestWordLen(pdata) {
          return bonusEligibleWords(pdata)
            .reduce((max, w) => Math.max(max, w.text.replace(/[()]/g, '').length), 0);
        }

        // Count of words for "Most Words" (bonus-eligible only)
        function wordsCount(pdata) {
          return bonusEligibleWords(pdata).length;
        }

        // Reset per-round per-player bookkeeping
        function resetRoundPlayerState(pdata) {
          pdata.roundScore = 0;
          pdata.challengeDeductions = 0;
          pdata.bonus = 0;
          pdata.gotLongestBonus = false;
          pdata.gotMostWordsBonus = false;
        }

        // Apply challenge deductions for a player's words:
        // - If a word is VALID and has a challenger, the *challenger* gets deduction.
        // - If a word is INVALID and has a challenger, the *owner* gets deduction.
        // (Invalid with no challenger = no deduction)
        function applyChallengeDeductionsForPlayer(round, player) {
          const pdata = round.players[player];
          pdata.forEach(word => {
            if (word.state === 'valid' && word.challenger) {
              round.players[word.challenger].challengeDeductions += word.score;
            } else if (word.state === 'invalid' && word.challenger) {
              pdata.challengeDeductions += word.score;
            }
          });
        }

        // ---------- Main ----------

        function recalculateScores() {
          // reset running totals
          players.forEach(player => { scores[player] = 0; });

          roundsData.forEach(round => {
            // reset round/player state
            players.forEach(player => resetRoundPlayerState(round.players[player]));

            // compute base + find candidates for bonuses
            let longestLength = 0;
            let mostWordsCount = 0;
            let longestPlayers = [];
            let mostWordsPlayers = [];

            players.forEach(player => {
              const pdata = round.players[player];

              // base score (including '-' penalties and def-only invalids)
              pdata.baseScore = baseScoreForPlayer(pdata);

              // track longest
              const pLongest = longestWordLen(pdata);
              if (pLongest > longestLength) {
                longestLength = pLongest;
                longestPlayers = [player];
              } else if (pLongest === longestLength && pLongest > 0) {
                longestPlayers.push(player);
              }

              // track most words
              const pCount = wordsCount(pdata);
              if (pCount > mostWordsCount) {
                mostWordsCount = pCount;
                mostWordsPlayers = [player];
              } else if (pCount === mostWordsCount && pCount > 0) {
                mostWordsPlayers.push(player);
              }
            });

            // apply challenge deductions
            players.forEach(player => applyChallengeDeductionsForPlayer(round, player));

            // bonuses (respect ties)
            if (longestWordBonus && longestPlayers.length === 1) {
              const p = longestPlayers[0];
              round.players[p].bonus += longestWordPoints;
              round.players[p].gotLongestBonus = true;
            }
            if (mostWordsBonus && mostWordsPlayers.length === 1) {
              const p = mostWordsPlayers[0];
              round.players[p].bonus += mostWordsPoints;
              round.players[p].gotMostWordsBonus = true;
            }

            // finalize round scores and add to running totals
            players.forEach(player => {
              const pdata = round.players[player];
              pdata.roundScore = Math.max(0, pdata.baseScore - pdata.challengeDeductions) + pdata.bonus;
              scores[player] += pdata.roundScore;
            });
          });

          updateScores();
        }

        // Handler for the gear button
        function prefillPlayFor(roundIdx, playerName, e) {
          e?.stopPropagation?.();
          const round = roundsData[roundIdx];
          if (!round) return;

          const pdata = round.players[playerName] || [];
          const tiles = pdata.map(w => w.text).join(' ');

          let oppMaxLongest = 0;
          let oppMaxMost = 0;
          players.forEach(p => {
            if (p === playerName) return;
            const opData = round.players[p] || [];
            oppMaxLongest = Math.max(oppMaxLongest, longestWordLen(opData));
            oppMaxMost    = Math.max(oppMaxMost,    wordsCount(opData));
          });

          window.QuiddlerTools?.prefillPlay?.({
            tiles,
            currentLongest: oppMaxLongest,
            currentMost: oppMaxMost
          });
        }

        function toCardToken(token) {
          const t = String(token || '').trim();
          return t.length > 1 ? `(${t})` : t;   // wrap multi-letter tiles like "er" ‚Üí "(er)"
        }

        // ========== Chit / Row Rendering Helpers ==========
        // Make the letter-points array for a word text (handles diphthongs)
        function pointsArrayFor(wordText) {
          const letters = parseCards(wordText.replace('-', ''));
          return letters.map(l => cardScores[l.replace(/[()]/g,'').toLowerCase()] || 1);
        }

        // "10 + 2 + 2 = 14"
        function breakdownStr(wordText) {
          const arr = pointsArrayFor(wordText);
          return arr.join(' + ');
          // return `${arr.join(' + ')} = ${arr.reduce((a,b)=>a+b,0)}`;
        }

        // Color class by state
        function chitColorClass(word) {
          return word.state === 'invalid'
            ? 'bg-red-300'
            : word.state === 'valid'
              ? 'bg-green-300'
              : 'bg-gray-200';
        }

        // HTML for a single chit (reusable for rounds or optimizer)
        function renderChit(word, opts = {}) {
          const {
            roundIdx = null,
            player = null,
            wordIdx = null,
            interactive = false,
            showDefIcon = true,
            showBreakdown = true,
            forceState = null,
            forceShowDefIcon = false,
            extraClasses = ''
          } = opts;

          const effectiveState = forceState ?? word.state;
          const tooltipAttr = showBreakdown
            ? `data-tippy-content="${breakdownStr(word.text).replace(/"/g,'&quot;')}"`
            : '';

          const colorClass =
            effectiveState === 'invalid' ? 'bg-red-200'
            : effectiveState === 'valid' ? 'bg-green-200'
            : 'bg-gray-200';

          const wantDefIcon = forceShowDefIcon || effectiveState === 'valid';
          const defIcon = wantDefIcon
            ? `<span class="ml-1 inline-flex items-center justify-center w-4 h-4 rounded-full bg-gray-500 hover:bg-gray-600 text-white cursor-pointer def-open"
                     data-word="${word.text.replace(/"/g,'&quot;')}"
                     data-tippy-content="Look up"
                     title="">
                 <!-- Heroicons: book-open (24/outline) -->
                 <svg xmlns="http://www.w3.org/2000/svg"
                      class="w-3 h-3"
                      viewBox="0 0 24 24" fill="none"
                      stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                   <path d="M12 6.75c-1.71-1.02-3.77-1.5-6-1.5v11.25c2.23 0 4.29.48 6 1.5m0-11.25c1.71-1.02 3.77-1.5 6-1.5v11.25c-2.23 0-4.29.48-6 1.5m0-11.25v11.25"/>
                 </svg>
               </span>`
          : '';


          // interactive wiring (only when interactive=true)
          const interAttrs = interactive
            ? `data-player="${player}" data-round="${roundIdx}" data-word="${wordIdx}"
               onclick="toggleChallenge(this,event)" ondblclick="noChallengerQuickToggle(this,event)"`
            : `aria-disabled="true"`;

          const cursorClass = interactive ? 'cursor-pointer hover:bg-opacity-80' : 'cursor-default';

          return `
            <button type="button"
              class="inline-flex items-baseline gap-1 px-1.5 py-0.5 rounded-md ${colorClass} ${cursorClass} ${extraClasses}
                     breakdown-tip ring-1 ring-black/5"
              ${tooltipAttr} ${interAttrs}>
              <span class="font-semibold tracking-tight">${word.text.toUpperCase()}</span>
              <span class="opacity-80">[${word.score}]</span>
              ${defIcon}
            </button>
          `;
        }



        // Row header segments
        function renderPlayerRowHeader(player, pdata) {
          const parts = [];
          parts.push(Math.max(pdata.baseScore, 0));
          if (pdata.challengeDeductions) parts.push(`- ${pdata.challengeDeductions}`);
          if (pdata.gotLongestBonus) parts.push(`+ü¶í`);
          if (pdata.gotMostWordsBonus) parts.push(`+ü•í`);
          const breakdown = parts.join(' ');

          return `
            <!-- Name -->
            <span class="w-28 sm:w-20 shrink-0 truncate" title="${player}">${player}</span>

            <!-- Score -->
            <span class="w-10 sm:w-10 shrink-0 tabular-nums">${pdata.roundScore}</span>

            <!-- Breakdown -->
            <span class="w-60 sm:w-32 shrink-0 text-gray-600"
                  title="${(pdata.challengeDeductions || pdata.bonus) ? '('+breakdown+')' : ''}">
              ${(pdata.challengeDeductions || pdata.bonus) ? '('+breakdown+')' : ''}
            </span>
          `;
        }


                // Interactive controls (edit + gear). Call only when interactive=true
        function renderRowControls(roundIdx, player) {
          return `
            <span class="w-10 shrink-0 flex items-center gap-1 justify-start">
              <button onclick="enterEditMode('${player}', ${roundIdx}, this)"
                      class="opacity-0 group-hover:opacity-100 transition">‚úèÔ∏è</button>
              <button onclick="prefillPlayFor(${roundIdx}, '${player}', event)"
                      class="opacity-0 group-hover:opacity-100 transition text-emerald-700 hover:text-emerald-900"
                      title="Open Play Helper">‚öôÔ∏è</button>
            </span>
          `;
        }


        // Render one player's row (interactive or static)
        function renderPlayerRow(roundIdx, player, pdata, {interactive = true} = {}) {
          const header = renderPlayerRowHeader(player, pdata);
          const controls = interactive ? renderRowControls(roundIdx, player) : '';

          const chits = pdata.map((word, i) =>
            renderChit(word, { roundIdx, player, wordIdx: i, interactive, showDefIcon: true })
          ).join(' ');

          // both live in the same cell; we toggle hidden on these two
          const editBlock = interactive ? `
            <div class="edit-container hidden">
              <div class="flex items-center gap-2">
                <input type="text" class="border rounded p-1 flex-1 min-w-0 edit-input"
                       value="${pdata.map(w=>w.text).join(' ')}">
                <button onclick="saveEdit('${player}', ${roundIdx}, this)" class="px-2">‚úîÔ∏è</button>
                <button onclick="cancelEdit(this)" class="px-2">‚ùå</button>
              </div>
            </div>
          ` : '';

          return `
            <div class="flex items-center gap-2 relative group flex-wrap">
              ${header}
              ${controls}

              <!-- Single shared cell for chits/edit -->
              <div class="flex-1 min-w-0">
                <div class="chit-container flex flex-wrap gap-1">
                  ${chits}
                </div>
                ${editBlock}
              </div>
            </div>
          `;
        }

        // Render a whole round block (interactive or static)
        function renderRound(round, roundIdx, {interactive = true} = {}) {
          const rows = players
            .map(player => renderPlayerRow(roundIdx, player, round.players[player], {interactive}))
            .join('');
          return `
            <div class="my-4 flex gap-4 border-b border-gray-200 pb-4">
              <div class="font-bold min-w-[50px] flex items-center justify-center text-xl">${round.roundNum}</div>
              <div class="flex flex-col gap-2">
                ${rows}
              </div>
            </div>
          `;
        }

        // Global flag so breakdown tooltips don't show while a def icon is hovered
        window.__defOpenHover = false;

        function initChitTooltips(container = document) {
          // 1) Initialize breakdown tooltips on the chit itself
          const breakdownInstances = tippy(container.querySelectorAll('.breakdown-tip'), {
            delay: [100, 50],
            animation: 'scale',
            allowHTML: true,
            // If we're over a def icon, suppress the breakdown tooltip entirely
            onTrigger(instance, event) {
              if (window.__defOpenHover) {
                event.preventDefault(); // don't even start the show cycle
              }
            },
            onShow(instance) {
              // Extra guard: do not show if the def icon is currently hovered
              return !window.__defOpenHover;
            }
          });

          // 2) Initialize "Look up" (book) tooltips on the def icon
          const defInstances = tippy(container.querySelectorAll('.def-open'), {
            delay: [100, 50],
            animation: 'scale',
            // When the def icon tooltip is about to show, hide any open breakdowns
            onShow() {
              window.__defOpenHover = true;
              breakdownInstances.forEach(inst => inst.hide());
            },
            onHidden() {
              window.__defOpenHover = false;
            }
          });

          // Optional: return instances if you ever need to programmatically hide them
          return { breakdownInstances, defInstances };
        }


        function updatePreviousRounds() {
          const html = roundsData
            .slice()
            .reverse()
            .map((round, revIdx) => {
              const roundIdx = roundsData.length - 1 - revIdx;
              return renderRound(round, roundIdx, { interactive: true });
            })
            .join('');

          const container = document.getElementById('previousRounds');
          container.innerHTML = html;

          // Wire dictionary openers (you already do this)
          container.querySelectorAll('.def-open').forEach(el => {
            el.addEventListener('click', async (e) => {
              e.stopPropagation();
              e.preventDefault();
              const w = el.getAttribute('data-word') || '';
              if (window.QuiddlerTools?.showDict) await window.QuiddlerTools.showDict(w);
            });
          });

          // Initialize both tooltips, coordinated
          initChitTooltips(container);
        }

        function enterEditMode(player, roundIdx, btn) {
          const row = btn.closest('.group');
          const cell = row.querySelector('.flex-1.min-w-0');
          if (!cell) return;

          const chits = cell.querySelector('.chit-container');
          const edit  = cell.querySelector('.edit-container');
          if (!edit) return;

          chits?.classList.add('hidden');
          edit.classList.remove('hidden');

          const input = edit.querySelector('.edit-input');
          if (input) {
            // focus cursor at end
            input.focus();
            const v = input.value; input.value = ''; input.value = v;

            // ‚úÖ Add Enter key handler
            input.addEventListener('keydown', function handler(e) {
              if (e.key === 'Enter') {
                e.preventDefault();
                saveEdit(player, roundIdx, btn);
                // Remove this listener so it doesn't stack
                input.removeEventListener('keydown', handler);
              }
            });
          }
        }


        function cancelEdit(btn) {
          const row = btn.closest('.group');
          const cell = row.querySelector('.flex-1.min-w-0');
          if (!cell) return;

          cell.querySelector('.edit-container')?.classList.add('hidden');
          cell.querySelector('.chit-container')?.classList.remove('hidden');
        }

        function saveEdit(player, roundIdx, btn) {
          const row = btn.closest('.group');
          const cell = row.querySelector('.flex-1.min-w-0');
          if (!cell) return;

          const input = cell.querySelector('.edit-input');
          const newWords = (input?.value || '').trim().split(/\s+/).filter(Boolean);

          roundsData[roundIdx].players[player] = newWords.map(word => ({
            text: word,
            score: calculateScore(parseCards(word.replace('-', ''))),
            state: word.startsWith('-') ? 'invalid' : 'neutral',
            challenger: null
          }));

          recalculateScores();
          updatePreviousRounds();
        }

        function updateScores() {
            document.getElementById('scoreTotals').innerHTML = players
                .map(player => ({ player, score: scores[player] }))
                .sort((a, b) => b.score - a.score)  // sort descending by score
                .map(({ player, score }) => `<li>${player}: ${score} points</li>`)
                .join('');
        }


        function toggleChallenge(btn, e) {
            e.stopPropagation();

            // First, remove any existing challenger dropdown
            document.querySelectorAll('.challenger-dropdown').forEach(el => el.remove());

            const roundIdx = btn.dataset.round;
            const player = btn.dataset.player;
            const wordIdx = btn.dataset.word;
            const wordObj = roundsData[roundIdx].players[player][wordIdx];

            if (wordObj.text.startsWith('-')) {
                return;
            }

            if (wordObj.state === 'valid' || wordObj.state === 'invalid') {
                wordObj.state = 'neutral';
                wordObj.challenger = null;
                recalculateScores();
                updatePreviousRounds();
                return;
            }

            const challengerDropdown = document.createElement('select');
            challengerDropdown.className = 'ml-2 p-1 border rounded challenger-dropdown';
            challengerDropdown.innerHTML = `<option value="">Select Challenger</option><option value="null"><i>No Challenge</i></option>` +
                players.filter(p => p !== player).map(p => `<option>${p}</option>`).join('');

            challengerDropdown.onchange = function() {
                if (this.value === "") {
                    this.remove();  // cancellable by selecting empty option
                    return;
                }
                if (this.value != "null") {
                    wordObj.challenger = this.value;
                }
                wordObj.state = validateWord(wordObj.text) ? 'valid' : 'invalid';
                recalculateScores();
                updatePreviousRounds();
                this.remove();
            };

            btn.after(challengerDropdown);

            // Add a click listener on document to cancel when clicking outside
            function clickOutsideHandler(event) {
                if (!challengerDropdown.contains(event.target)) {
                    challengerDropdown.remove();
                    document.removeEventListener('click', clickOutsideHandler);
                }
            }
            setTimeout(() => { // Prevent immediate trigger on creation click
                document.addEventListener('click', clickOutsideHandler);
            }, 0);
        }


        document.getElementById('playersInput').addEventListener('input', function() {
            const players = this.value
                .split(',')
                .map(p => p.trim())
                .filter(p => p.length > 0);

            const longestWordCheckbox = document.getElementById('longestWordBonus');
            const mostWordsCheckbox = document.getElementById('mostWordsBonus');

            if (players.length <= 1) {
                longestWordCheckbox.checked = false;
                mostWordsCheckbox.checked = false;
            } else if (players.length === 2) {
                longestWordCheckbox.checked = true;
                mostWordsCheckbox.checked = false;
            } else {
                longestWordCheckbox.checked = true;
                mostWordsCheckbox.checked = true;
            }
        });

        function updateBonusInputs() {
            document.getElementById('longestWordPoints').disabled =
                !document.getElementById('longestWordBonus').checked;

            document.getElementById('mostWordsPoints').disabled =
                !document.getElementById('mostWordsBonus').checked;
        }

        // Initialize input states correctly
        updateBonusInputs();

        // Add listeners for immediate feedback
        document.getElementById('longestWordBonus').addEventListener('change', updateBonusInputs);
        document.getElementById('mostWordsBonus').addEventListener('change', updateBonusInputs);

        // ---------- Build trie ----------
        function buildTrie(words, maxDepth = 10) {
          const root = { children: Object.create(null), end: false };
          for (const wRaw of words) {
            const w = wRaw.toLowerCase();
            let node = root, depth = 0;
            for (const ch of w) {
              if (depth >= maxDepth) break;
              node = node.children[ch] ??= { children: Object.create(null), end: false };
              depth++;
            }
            if (w.length <= maxDepth) node.end = true;
          }
          return root;
        }

        // ---------- Count rack ----------
        function countRack(tiles, digraphSet) {
          const singleCounts = Object.create(null);
          const digraphCounts = Object.create(null);
          for (const raw of tiles) {
            const tile = raw.toLowerCase();
            if (digraphSet.has(tile)) digraphCounts[tile] = (digraphCounts[tile] || 0) + 1;
            else singleCounts[tile] = (singleCounts[tile] || 0) + 1;
          }
          return { singleCounts, digraphCounts };
        }

        // ---------- Common gate helper (runtime knob) ----------
        function makeCommonGateFromEntries(
          entries,
          { mode = 'zipf', minZipF = 3.8, topK = 10000, override2and3 = false } = {},
          lemmatizer
        ) {
          // entries: [ [lemma, zipf, rank], ... ]
          const MAP = new Map(entries.map(([l, z, r]) => [l, { zipf: z, rank: r }]));

          function lemma(word) {
            word = word.toLowerCase();
            let best = word;
            if (lemmatizer?.noun)      { const n = lemmatizer.noun(word);      if (n && n.length < best.length) best = n; }
            if (lemmatizer?.verb)      { const v = lemmatizer.verb(word);      if (v && v.length < best.length) best = v; }
            if (lemmatizer?.adjective) { const a = lemmatizer.adjective(word); if (a && a.length < best.length) best = a; }
            if (lemmatizer?.adverb)    { const r = lemmatizer.adverb(word);    if (r && r.length < best.length) best = r; }
            return best;
          }

          return function isCommon(word) {
            // Let short words (2‚Äì3 chars) through if requested
            if (override2and3 && word.length >= 2 && word.length <= 3) return true;

            const l = lemma(word);
            const rec = MAP.get(l);
            if (!rec) return false;

            if (mode === 'zipf')  return rec.zipf >= minZipF;
            if (mode === 'rank')  return rec.rank <= topK;
            if (mode === 'either') return rec.zipf >= minZipF || rec.rank <= topK;
            if (mode === 'both')   return rec.zipf >= minZipF && rec.rank <= topK;
            return false;
          };
        }


        // ---------- Generate candidates (keep all distinct usages) ----------
        function generateWordCandidates(trie, rackCounts, minLen = 2, opts = {}) {
          const { commonGate = null } = opts;

          const out = [];
          const path = [];
          const usedTokens = [];
          const scoreTokens = ts => ts.reduce((s, t) => s + (cardScores[t] || 0), 0);

          function usageFromTokens(tokens) {
            const u = { singleCounts: Object.create(null), digraphCounts: Object.create(null) };
            for (const t of tokens) {
              if (t.length === 1) u.singleCounts[t] = (u.singleCounts[t] || 0) + 1;
              else u.digraphCounts[t] = (u.digraphCounts[t] || 0) + 1;
            }
            return u;
          }
          function usageKey(u) {
            const s = Object.entries(u.singleCounts).sort().map(([k,v])=>k+v).join('');
            const d = Object.entries(u.digraphCounts).sort().map(([k,v])=>k+v).join('');
            return s + '|' + d;
          }

          const perWord = new Map();

          function pushResult() {
            const plainWord = path.join('');

            // Skip words that are a single digraph tile (e.g., "qu", "th")
            if (usedTokens.length === 1 && usedTokens[0].length > 1) return;

            // Skip if doesn't pass gate
            if (commonGate && !commonGate(plainWord)) return;

            const usage = usageFromTokens(usedTokens);
            const key = usageKey(usage);

            const displayWord = usedTokens.map(t => t.length > 1 ? `(${t})` : t).join('');

            let bucket = perWord.get(plainWord);
            if (!bucket) { bucket = new Map(); perWord.set(plainWord, bucket); }
            if (!bucket.has(key)) {
              bucket.set(key, { 
                word: displayWord, 
                score: scoreTokens(usedTokens), 
                usage, 
                length: plainWord.length 
              });
            }
          }

          function dfs(node, singleCounts, digraphCounts) {
            if (node.end && path.length >= minLen) pushResult();

            for (const [L, c] of Object.entries(singleCounts)) {
              if (c > 0 && node.children[L]) {
                singleCounts[L]--; path.push(L); usedTokens.push(L);
                dfs(node.children[L], singleCounts, digraphCounts);
                usedTokens.pop(); path.pop(); singleCounts[L]++;
              }
            }
            for (const [DG, c] of Object.entries(digraphCounts)) {
              if (c > 0) {
                const a = DG[0], b = DG[1];
                const n1 = node.children[a], n2 = n1 && n1.children[b];
                if (n2) {
                  digraphCounts[DG]--; path.push(a,b); usedTokens.push(DG);
                  dfs(n2, singleCounts, digraphCounts);
                  usedTokens.pop(); path.pop(); path.pop(); digraphCounts[DG]++;
                }
              }
            }
          }

          dfs(trie, { ...rackCounts.singleCounts }, { ...rackCounts.digraphCounts });

          for (const bucket of perWord.values()) for (const cand of bucket.values()) out.push(cand);
          return out;
        }

        // ---------- Choose best play (no-flatten discard, leftover penalty, strict bonuses) ----------
        function chooseBestPlay(
          candidates,
          rackCounts,
          params = {}
        ) {
          const {
            currentLongest = Infinity,
            currentMost    = Infinity,
            noDiscard      = false,
            longestBonus   = 10,
            mostBonus      = 10,
          } = params;

          // order for speed
          candidates.sort((a, b) =>
            (b.score / Math.max(1, b.length)) - (a.score / Math.max(1, a.length)) ||
            (b.score - a.score) ||
            (b.length - a.length)
          );

          const remSingles  = { ...rackCounts.singleCounts };
          const remDigraphs = { ...rackCounts.digraphCounts };

          const remainingValue = () => {
            let s = 0;
            for (const [L, c] of Object.entries(remSingles))  s += (cardScores[L] || 0) * c;
            for (const [D, c] of Object.entries(remDigraphs)) s += (cardScores[D] || 0) * c;
            return s;
          };

          function totalRemainingCount() {
            let n = 0;
            for (const c of Object.values(remSingles))  n += c;
            for (const c of Object.values(remDigraphs)) n += c;
            return n;
          }

          function listRemainingTiles() {
            const arr = [];
            for (const [t, c] of Object.entries(remSingles))  for (let i = 0; i < c; i++) arr.push(t);
            for (const [t, c] of Object.entries(remDigraphs)) for (let i = 0; i < c; i++) arr.push(t);
            return arr;
          }

          function bestDiscardInfo() {
            // pick the remaining tile with highest face value
            let bestTile = null, bestVal = -Infinity;
            for (const [t, c] of Object.entries(remSingles)) {
              if (c > 0) {
                const v = cardScores[t] || 0;
                if (v > bestVal) { bestVal = v; bestTile = t; }
              }
            }
            for (const [t, c] of Object.entries(remDigraphs)) {
              if (c > 0) {
                const v = cardScores[t] || 0;
                if (v > bestVal) { bestVal = v; bestTile = t; }
              }
            }
            return { bestTile, bestVal: (bestVal === -Infinity ? 0 : bestVal) };
          }

          const fits = (u) => {
            for (const [L, c] of Object.entries(u.singleCounts))  if ((remSingles[L]  || 0) < c) return false;
            for (const [D, c] of Object.entries(u.digraphCounts)) if ((remDigraphs[D] || 0) < c) return false;
            return true;
          };
          const apply = (u, sign) => {
            for (const [L, c] of Object.entries(u.singleCounts))  remSingles[L]  -= sign * c;
            for (const [D, c] of Object.entries(u.digraphCounts)) remDigraphs[D] -= sign * c;
          };

          let best = {
            baseScore: -Infinity,
            words: [],
            longest: 0,
            count: 0,
            leftoverValue: Infinity,
            totalScore: -Infinity,
            bonus: { longest: 0, most: 0 },
            discardTile: null,
            unusedTiles: [],
          };

          const cur = { baseScore: 0, words: [], longest: 0, count: 0 };

          function evalCurrent() {
            const remCount = totalRemainingCount();

            // enforce discard rule unless noDiscard is enabled
            if (!noDiscard && remCount === 0) return; // illegal: must have at least one tile to discard

            const remVal = remainingValue();
            let penalty, discardTile, unusedTiles;

            if (noDiscard) {
              // allow using all tiles; no discard removed
              penalty     = remVal;
              discardTile = null;
              unusedTiles = listRemainingTiles();
            } else {
              // choose best discard and subtract only the rest
              const { bestTile, bestVal } = bestDiscardInfo();
              penalty     = remVal - bestVal;
              discardTile = bestTile;

              const leftovers = listRemainingTiles();
              let removed = false;
              unusedTiles = [];
              for (const t of leftovers) {
                if (!removed && t === bestTile) { removed = true; continue; }
                unusedTiles.push(t);
              }
            }

            const bonus = {
              longest: cur.longest > currentLongest ? longestBonus : 0,
              most:    cur.count   > currentMost    ? mostBonus   : 0,
            };

            const total = Math.max(cur.baseScore - penalty, 0) + bonus.longest + bonus.most;

            if (total > best.totalScore) {
              best = {
                baseScore: cur.baseScore,
                words: cur.words.map(({ word, score }) => ({ word, score })),
                longest: cur.longest,
                count: cur.count,
                leftoverValue: penalty,
                totalScore: total,
                bonus,
                discardTile,
                unusedTiles,
              };
            }
          }

          function dfs(i) {
            // optimistic bound: assume we can spend all remaining (penalty 0) and win both bonuses
            const ub = cur.baseScore + remainingValue() + longestBonus + mostBonus;
            if (ub <= best.totalScore) return;

            if (i === candidates.length) { evalCurrent(); return; }

            const w = candidates[i];

            if (fits(w.usage)) {
              apply(w.usage, +1);
              cur.words.push(w);
              const prevLongest = cur.longest;
              cur.longest = Math.max(cur.longest, w.length);
              cur.baseScore += w.score;
              cur.count += 1;

              dfs(i + 1);

              cur.count -= 1;
              cur.baseScore -= w.score;
              cur.longest = prevLongest;
              cur.words.pop();
              apply(w.usage, -1);
            }

            dfs(i + 1);
          }

          dfs(0);

          return {
            words: best.words,
            baseScore: best.baseScore,
            leftoverValue: best.leftoverValue,
            bonus: best.bonus,
            totalScore: best.totalScore,
            longestWordLength: best.longest,
            wordCount: best.count,
            discardTile: best.discardTile,
            unusedTiles: best.unusedTiles,
          };
        }

        function renderOptimizedPlayFromResult(containerId, result) {
          const el = document.getElementById(containerId);
          if (!el) return;

          // Chits (neutral used, invalid unused)
          const usedWordChits = (result.words || [])
            .map(w => renderChit(
              { text: w.word, score: w.score, state: 'neutral' },
              { interactive: false, forceState: 'neutral', forceShowDefIcon: true, showDefIcon: true }
            ))
            .join(' ');

          let unusedChitHTML = '';
          if (Array.isArray(result.unusedTiles) && result.unusedTiles.length) {
            const combined = '-' + result.unusedTiles.map(toCardToken).join('');
            const unusedScore = calculateScore(parseCards(combined.replace('-', '')));
            unusedChitHTML = renderChit(
              { text: combined, score: unusedScore, state: 'invalid' },
              { interactive: false, forceState: 'invalid', showDefIcon: false }
            );
          }

          let discardChitHTML = '';
          if (result.discardTile) {
            const discardText = '-' + toCardToken(result.discardTile);
            const discardScore = calculateScore(parseCards(discardText.replace('-', '')));
            discardChitHTML = renderChit(
              { text: discardText, score: discardScore, state: 'neutral' },
              {
                interactive: false,
                forceState: 'neutral',
                showDefIcon: false,
                extraClasses: 'bg-yellow-200'  // <-- override bg color to yellow
              }
            );
          }

          // Scores
          const base     = Number(result.baseScore ?? 0);
          const leftover = Number(result.leftoverValue ?? 0);
          const baseShown = Math.max(base - leftover, 0); // <-- show base minus leftoverValue in the breakdown

          const bLong = Number(result?.bonus?.longest ?? 0);
          const bMost = Number(result?.bonus?.most ?? 0);
          const total = Number(result.totalScore ?? (base + bLong + bMost));
          const hasBonus = Boolean(bLong || bMost);

          // Breakdown like main UI, but gray & same size as score: "(baseShown + ü¶í + ü•í)"
          const breakdownInline = hasBonus
            ? ` <span class="text-gray-600 text-[18px]">(${baseShown}${bLong ? ' + ü¶í' : ''}${bMost ? ' + ü•í' : ''})</span>`
            : '';

          el.innerHTML = `
            <div class="space-y-2">
              <!-- Score line above -->
              <div class="flex items-baseline gap-2">
                <span class="text-[18px] font-semibold">Score:</span>
                <span class="text-[18px] font-semibold tabular-nums">${total}</span>
                ${breakdownInline}
              </div>

              <!-- Chits -->
              <div class="flex flex-wrap items-center gap-1">
                ${usedWordChits} ${unusedChitHTML} ${discardChitHTML}
              </div>
            </div>
          `;

            // Hook dictionary icons in optimizer output
            el.querySelectorAll('.def-open').forEach(icon => {
              icon.addEventListener('click', async (e) => {
                e.stopPropagation();
                e.preventDefault();
                const w = icon.getAttribute('data-word') || '';
                if (window.QuiddlerTools?.showDict) await window.QuiddlerTools.showDict(w);
              });
            });

            // Initialize coordinated tooltips for this block
            initChitTooltips(el);

        }


        // ===== Tools Drawer =====
        function initToolsDrawer(){
          const drawer  = document.getElementById('toolsDrawer');
          const closeBtn= document.getElementById('toolsCloseBtn');
          const backdrop= document.getElementById('toolsBackdrop');

          function openDrawer() {
            drawer.classList.remove('translate-x-full');
            backdrop.classList.remove('hidden');
            // force reflow for transition
            void backdrop.offsetWidth;
            backdrop.classList.remove('opacity-0');
          }
          function closeDrawer() {
            drawer.classList.add('translate-x-full');
            backdrop.classList.add('opacity-0');
            const onEnd = () => { backdrop.classList.add('hidden'); backdrop.removeEventListener('transitionend', onEnd); };
            backdrop.addEventListener('transitionend', onEnd);
          }

          document.getElementById('dictToolBtn')?.addEventListener('click', () => {
            openDrawer();
            showTab('dict'); // switch to Dictionary tab
          });
          document.getElementById('optToolBtn')?.addEventListener('click', () => {
            openDrawer();
            showTab('play'); // switch to Play Helper / Optimizer tab
          });
          closeBtn.addEventListener('click', closeDrawer);
          backdrop.addEventListener('click', closeDrawer);
          document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') closeDrawer(); });

          // Tabs
          const tabDict = document.getElementById('toolsTabDict');
          const tabPlay = document.getElementById('toolsTabPlay');
          const panelDict = document.getElementById('toolsPanelDict');
          const panelPlay = document.getElementById('toolsPanelPlay');

          function showTab(which) {
            const isDict = which === 'dict';
            panelDict.classList.toggle('hidden', !isDict);
            panelPlay.classList.toggle('hidden', isDict);
            tabDict.classList.toggle('bg-white', isDict);
            tabDict.classList.toggle('text-gray-900', isDict);
            tabDict.classList.toggle('bg-gray-100', !isDict);
            tabDict.classList.toggle('text-gray-600', !isDict);
            tabPlay.classList.toggle('bg-white', !isDict);
            tabPlay.classList.toggle('text-gray-900', !isDict);
            tabPlay.classList.toggle('bg-gray-100', isDict);
            tabPlay.classList.toggle('text-gray-600', isDict);
          }
          tabDict.addEventListener('click', () => showTab('dict'));
          tabPlay.addEventListener('click', () => showTab('play'));
          showTab('dict');

          // ===== Dictionary (async, render <br>) =====
          const dictInput  = document.getElementById('dictInput');
          const dictGo     = document.getElementById('dictGo');
          const dictResult = document.getElementById('dictResult');
          const dictEmpty  = document.getElementById('dictEmpty');
          let dictSeq = 0;

          async function renderDefinition(word) {
            const localWrap  = document.getElementById('dictLocalWrap');
            const localEl    = document.getElementById('dictLocal');
            const onlineWrap = document.getElementById('dictOnlineWrap');
            const onlineEl   = document.getElementById('dictOnline');
            const loadingEl  = document.getElementById('dictOnlineLoading');
            const w = (word || '').trim();
            // No input ‚Üí hide everything
            if (!w) {
              localWrap?.classList.add('hidden');
              onlineWrap?.classList.add('hidden');
              loadingEl?.classList.add('hidden');
              return;
            }
            // Local: always show a section; fallback text if missing
            const local = getWordDefinitionLocal(w);
            if (localWrap && localEl) {
              localEl.innerHTML = local ?? '<span class="text-gray-500">No definition found</span>';
              localWrap.classList.remove('hidden');
            }
            // Prepare online area
            onlineWrap?.classList.add('hidden');
            loadingEl?.classList.remove('hidden');
            // Fetch online
            const online = await getWordDefinitionAPI(w);
            // Update online section
            loadingEl?.classList.add('hidden');
            if (online && onlineEl && onlineWrap) {
              onlineEl.innerHTML = online; // supports <br>
              onlineWrap.classList.remove('hidden');
            } else {
              onlineWrap?.classList.add('hidden');
            }
          }

          async function doLookup(){ await renderDefinition(dictInput.value); }
          dictGo.addEventListener('click', doLookup);
          dictInput.addEventListener('keydown', async (e)=>{
            if (e.key === 'Enter') await doLookup();
            if (e.key === 'Escape') { dictInput.value = ''; renderDefinition(''); }
          });

          // ===== Play Helper =====
          const tilesInput        = document.getElementById('tilesInput');
          const optCommonOnly     = document.getElementById('optCommonOnly');
          const optCommonOverride = document.getElementById('optCommonOverride');
          const optZipf           = document.getElementById('optZipf');
          const zipfVal           = document.getElementById('zipfVal');
          const optCurrentLongest        = document.getElementById('optCurrentLongest');
          const optCurrentMost           = document.getElementById('optCurrentMost');
          const playGo            = document.getElementById('playGo');
          const playStatus        = document.getElementById('playStatus');
          const playResult        = document.getElementById('playResult');

          function updateCommonOptions() {
            const enabled = optCommonOnly.checked;
            optCommonOverride.disabled = !enabled;
            optZipf.disabled = !enabled;
            optCommonOverride.closest('label').classList.toggle('opacity-50', !enabled);
            optZipf.classList.toggle('opacity-50', !enabled);
          }
          optCommonOnly.addEventListener('change', updateCommonOptions);
          updateCommonOptions();

          const fmtZipf = v => Number(v).toFixed(1);
          zipfVal.textContent = fmtZipf(optZipf.value);
          optZipf.addEventListener('input', () => { zipfVal.textContent = fmtZipf(optZipf.value); });

          function cleanInt(el){ const n = Number(el.value); return Number.isFinite(n) && n >= 0 ? Math.floor(n) : 0; }

          playGo.addEventListener('click', onFindBestPlay);

          async function onFindBestPlay() {
            const tiles = tilesInput.value.trim().replace(/[, -]+/g, "");
            const noDiscard      = !!optNoDiscard.checked;
            const commonOnly     = !!optCommonOnly.checked;
            const override2and3  = commonOnly ? !!optCommonOverride.checked : null;
            const minZipF        = commonOnly ? Number(optZipf.value) : null;
            const currentLongest = cleanInt(optCurrentLongest);
            const currentMost    = cleanInt(optCurrentMost);

            playStatus.textContent = 'Searching‚Ä¶';
            playResult.classList.remove('hidden');
            playResult.innerHTML = '';
  
            try {
              const result = await optimize({ tiles, noDiscard, commonOnly, override2and3, minZipF, currentLongest, currentMost });
  
              playStatus.textContent = '';
  
              if (result && Array.isArray(result.words) && result.words.length > 0) {
                renderOptimizedPlayFromResult('playResult', result);
              } else {
                playResult.innerHTML = '<div class="text-sm text-gray-500">No playable words found.</div>';
              }
            } catch (err) {
              console.error(err);
              playStatus.textContent = '';
              playResult.innerHTML = '<div class="text-sm text-red-600">Error computing best play.</div>';
            }
          }

          async function optimize({ tiles, noDiscard, commonOnly, override2and3, minZipF, currentLongest, currentMost }) {
            rack = parseCards(tiles).map(w => w.replace(/[()]/g, '').toLowerCase());
            rackCounts = countRack(rack, DIGRAPHS);

            if (commonOnly) {
                commonGate = makeCommonGateFromEntries(wordFreq, {
                    mode: "zipf", 
                    override2and3,
                    minZipF, 
                    lemmatizer, 
                });
            } else {
                commonGate = null;
            }
            candidates = generateWordCandidates(trie, rackCounts, minLen=2, {commonGate});
            bestplay = chooseBestPlay(candidates, rackCounts, {
                noDiscard, 
                currentLongest: currentLongest == 0 ? Infinity : currentLongest, 
                currentMost: currentMost == 0 ? Infinity : currentMost, 
                longestBonus: longestWordPoints, 
                mostBonus: mostWordsPoints
            });
            console.log(bestplay);
            return bestplay;
          }

          // Expose a tiny public API for use elsewhere
          window.QuiddlerTools = {
            open: openDrawer,
            close: closeDrawer,
            showDict: async (word) => {
              openDrawer();
              showTab('dict');
              dictInput.value = word || '';
              await renderDefinition(dictInput.value);
            },
            showPlay: () => {
              openDrawer();
              showTab('play');
            },

            prefillPlay: ({ tiles, currentLongest, currentMost }) => {
              openDrawer(); showTab('play');
              const tilesInput = document.getElementById('tilesInput');
              const optNoDiscard = document.getElementById('optNoDiscard');
              const optCurrentLongest = document.getElementById('optCurrentLongest');
              const optCurrentMost = document.getElementById('optCurrentMost');
              const playResult = document.getElementById('playResult');
              const playStatus = document.getElementById('playStatus');

              // fill fields
              if (tilesInput) tilesInput.value = tiles ?? '';
              if (optCurrentLongest && Number.isFinite(currentLongest)) optCurrentLongest.value = String(currentLongest);
              if (optCurrentMost && Number.isFinite(currentMost))       optCurrentMost.value    = String(currentMost);
              optNoDiscard.checked = true;

              // clear previous solution
              if (playStatus) playStatus.textContent = '';
              if (playResult) {
                playResult.innerHTML = '';
                playResult.classList.add('hidden');
              }

              // focus tiles for quick edits
              setTimeout(() => tilesInput?.focus(), 0);
            }
          };

        };

        initToolsDrawer();
        // Initialize tooltips for the drawer buttons
        tippy('#dictToolBtn', { placement: 'left', animation: 'scale' });
        tippy('#optToolBtn', { placement: 'left', animation: 'scale' });

        // ===== Example usage =====
        const trie = buildTrie(Object.keys(validWordsMap), maxDepth=maxRound);
        const lemmatizer = window.winkLemmatizer;



    </script>
</body>
</html>
